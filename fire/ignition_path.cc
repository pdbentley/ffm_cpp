#include <string>

#include "ffm_util.h"
#include "ignition_path.h"


/*!\brief Categorises a fire as spreading or not. 

  \return true if and only if the rate of spread is at least
  ffm_settings::minRateForStratumSpread for at least ffm_settings::minTimeStepsForStratumSpread 
  time steps, otherwise returns false.
*/
bool IgnitionPath::spreads() const {
  int count = 0;
  for (int i = 0; i < size(); ++i){
    if (ros(i) > ffm_settings::minRateForStratumSpread) 
      ++count;
    if (count >= ffm_settings::minTimeStepsForStratumSpread) return true;
  }
  return false;
}

/*!\brief Mean flame length from all segments.
  \return The mean flame length from all segments of the IgnitionPath. 
  If ignoreZeros == true the only non-zero flame lengths will be used to 
  compute the mean, otherwise all flame lengths will be used
*/
double IgnitionPath::meanFlameLength(const bool& ignoreZeros) const {
  if (empty()) return 0.0;
  std::vector<double> vals;
  vals.resize(size());
  transform(ignitedSegments_.begin(), ignitedSegments_.end(), vals.begin(), 
	    [this](const Seg& s){return species().flameLength(s.length());});
  return ffm_util::mean(vals, ignoreZeros);
}


/*!\brief Standard deviation of flame lengths from all segments.
  \return The standard deviation of the flame lengths from all segments of the IgnitionPath. 
  If ignoreZeros == true the only non-zero flame lengths will be used to 
  compute the standard deviation, otherwise all flame lengths will be used
*/
double IgnitionPath::stdDevFlameLength(const bool& ignoreZeros) const {
  if (size() < 2) return 0.0;
  std::vector<double> vals;
  vals.resize(size());
  transform(ignitedSegments_.begin(), ignitedSegments_.end(), vals.begin(), 
	    [this](const Seg& s){return species().flameLength(s.length());});
  return ffm_util::stdDev(vals, ignoreZeros);
}


/*!\brief The FlameSeries associated with the IgnitionPath
  \param windSpeed The relevant wind speed used for computation of the flame angles
  \param slope
  \return The FlameSeries generated by the IgnitionPath.
*/
FlameSeries IgnitionPath::flameSeries(const double& windSpeed, 
				      const double& slope) const {
  FlameSeries retValue(level_);
  if (!empty()) {
    retValue.flames().reserve(size());
    for (int i = 0; i < size(); ++i) retValue.addFlame(flame(i, windSpeed, slope));
  }
  return retValue;
}

/*!\brief Extract a rate of spread
  \param idx
  \return The rate of spread computed at the idx-th segment, 
  counting from idx = 0.
*/
double IgnitionPath::ros(const int& idx) const {
  if (idx >= size()) return 0;
  if (idx == 0) {
    Seg s = ignitedSegments_.at(0);
    return (s.end().x() - s.start().x())/ffm_settings::computationTimeInterval;
  } else 
    return (ignitedSegments_.at(idx).end().x() - ignitedSegments_.at(idx-1).end().x())/
      ffm_settings::computationTimeInterval;
}

/*!\brief Basic rate of spread calculation
  \return The average rate of spread of all segments in the IgnitionPath 
  whose rate of spread exceeds ffm_settings::minRateForStratumSpread.
*/
double IgnitionPath::basicROS() const {
  if (empty()) return 0;
  double sum = 0, x = ignitedSegments_.front().start().x();
  int count = 0;
  for (const Seg& seg : ignitedSegments_) {
    double tmp = (seg.end().x() - x)/ffm_settings::computationTimeInterval;
    if (tmp > ffm_settings::minRateForStratumSpread){
      sum += tmp;
      ++count;
    }
    x = seg.end().x();
  }
  return count == 0 ? 0 : sum / count;
}

/*!\brief Non-independent rate of spread
  \return The quotient of the total horizontal distance travelled and 
  the sum of the time to ignition and the time period covered by the IgnitionPath.
*/
double IgnitionPath::nonIndependentROS() const {
  if (empty()) return 0;
  // return (ignitedSegments_.back().end().x() - ignitedSegments_.front().start().x())/
  //   (ffm_settings::computationTimeInterval*(size() + startTimeStep_));
  return (maxX() - ignitedSegments_.front().start().x())/
    (ffm_settings::computationTimeInterval*(size() + startTimeStep_));
}

/*!\brief Time of spread
  \return The time in seconds for which spread by the 
  IgnitionPath exceeded ffm_settings::minRateForStratumSpread.
*/
 double IgnitionPath::timeOfSpread() const {
  if (empty()) return 0;
  int count = 0;
  for (int i = 0; i <= size() - 1; ++i)
    count += ros(i) >= ffm_settings::minRateForStratumSpread ? 1 : 0;
  return count*ffm_settings::computationTimeInterval;
}

//printing 

/*!\brief Printing
  \return A formatted string describing the ignition path.
*/
std::string IgnitionPath::printToString() const{
  std::string str;
  char s[100];

  str =  "Path type:                " + ignitionPathTypeStringMap.at(type_) + "\n";
  str += "Level:                    " + levelStringMap.at(level_) + "\n";
  str += "Species:                  " + species_.name() + "\n";
  sprintf(s, "Flame duration (sec):     %.2f\n", species_.flameDuration());
  str += std::string(s); 
  sprintf(s,"Ignition start time step: %d", startTimeStep_);
  str += std::string(s);
  str += "\nIgnited segments:\n";
  if (!ignitedSegments_.empty()){
    str += "                                             Length (m)\n";
    str += "      Start               Finish            Segmt  Flame\n";
  }

  int i = 1;
  for (const auto& sg : ignitedSegments_){
    sprintf(s,"%4d: ",i);
    str += std::string(s);
    str += sg.printToString() + "  ";
    sprintf(s, "%.3f", sg.length());
    str += std::string(s) + "  ";
    sprintf(s, "%.2f", species_.flameLength(sg.length()));
    str += std::string(s) + "\n";
    ++i;
  }
  return str;
}

